% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/singR.R
\name{singR}
\alias{singR}
\title{sing method for data integration}
\usage{
singR(
  dX,
  dY,
  n.comp.X = NULL,
  n.comp.Y = NULL,
  df = 0,
  rho_extent = "small",
  Cplus = T,
  tol = 1e-10,
  stand = F,
  distribution = "JB",
  maxiter = 1500,
  individual = F
)
}
\arguments{
\item{dX}{original dataset for decomposition, matrix of n x px.}

\item{dY}{original dataset for decomposition, matrix of n x py.}

\item{n.comp.X}{the number of non-Gaussian components in dataset X. If null, will estimate the number using ICtest::FOBIasymp.}

\item{n.comp.Y}{the number of non-Gaussian components in dataset Y. If null, will estimate the number using ICtest::FOBIasymp.}

\item{df}{default value=0 when use JB, if df>0, estimates a density for the loadings using a tilted Gaussian (non-parametric density estimate).}

\item{rho_extent}{Controls similarity of the scores in the two datasets. small, medium or large is defined from the JB statistic. Try "small" and see if the loadings are equal, then try others if needed.}

\item{Cplus}{whether to use C code (faster) in curvilinear search.}

\item{tol}{difference tolerance in curvilinear search.}

\item{stand}{whether to use standardization, if true, it will make the column and row means to 0 and columns sd to 1. If false, it will only make the row means to 0.}

\item{distribution}{"JB" or "tiltedgaussian"; "JB" is much faster. In SING, this refers to the "density" formed from the vector of loadings. "tiltedgaussian" with large df can potentially model more complicated patterns.}

\item{maxiter}{the max iteration number for the curvilinear search.}

\item{individual}{whether to return the individual non-Gaussian components, default value = F.}
}
\value{
Function outputs a list including the following:
\describe{
      \item{\code{Sjx}}{variable loadings for joint NG components in dataset X with matrix rj x px.}
      \item{\code{Sjy}}{variable loadings for joint NG components in dataset Y with matrix rj x py.}
      \item{\code{Six}}{variable loadings for individual NG components in dataset X with matrix riX x px.}
      \item{\code{Siy}}{variable loadings for individual NG components in dataset Y with matrix riX x py.}
      \item{\code{Mix}}{scores of individual NG components in X with matrix n x riX.}
      \item{\code{Miy}}{scores of individual NG components in Y with matrix n x riY.}
      \item{\code{est.Mj}}{joint scores Mj for both datasets with matrix n x rj.}
      \item{\code{C_plus}}{whether to use C version of curvilinear search.}
      \item{\code{rho_extent}}{the weight of rho in search}
      \item{\code{df}}{degree of freedom, = 0 when use JB, >0 when use tiltedgaussian.}
}
}
\description{
sing method for data integration
}
\examples{
\dontrun{
#get simulation data
library(singR)
data(exampledata)

# use JB stat to compute with singR
output_JB=singR(dX=exampledata$dX,dY=exampledata$dY,df=0,rho_extent="small",distribution="JB",individual=TRUE)

# use tiltedgaussian distribution to compute with singR. The tiltedgaussian is more accurate and slower.
output_tilted=singR(dX=exampledata$dX,dY=exampledata$dY,df=5,rho_extent="small",distribution="tiltedgaussian",individual=TRUE)

# use frobICA to show the difference of JB and tiltedgaussian
frobICA_JB=frobICA(M1 = t(output_JB$est.Mj),M2 = t(exampledata$mj),standardize = T) #0.00715176
frobICA_tilted=frobICA(M1 = t(output_tilted$est.Mj),M2 = t(exampledata$mj),standardize = T) #0.00715178

}
}
